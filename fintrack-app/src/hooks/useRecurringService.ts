import { useRecurringStore } from '@/store/useRecurringStore';
import { useTransactionStore } from '@/store/useTransactionStore';
import { addDays, addWeeks, addMonths, addYears, isBefore, isSameDay } from 'date-fns';

export const useRecurringService = () => {
    const { rules, updateRule } = useRecurringStore();
    const { addTransaction } = useTransactionStore();

    const processRules = async () => {
        const today = new Date();
        let processedCount = 0;

        // Iterate sequentially to avoid race conditions with async store updates
        for (const rule of rules) {
            if (!rule.active) continue;

            let nextDueDate = new Date(rule.nextDue);
            let safetyLimit = 0;
            
            // We need to keep track if we updated this specific rule to avoid "stale closure" issues
            // relying on 'rule' object from the outer scope if we were modifying it.
            // But here we are calculating next dates locally.
            
            let ruleUpdated = false;
            let currentNextDue = nextDueDate;

            while ((isBefore(currentNextDue, today) || isSameDay(currentNextDue, today)) && safetyLimit < 12) {
                // Generate Transaction
                try {
                    await addTransaction({
                        ...rule.template,
                        // id is generated by the store/backend
                        date: currentNextDue.toISOString(),
                    });

                    // Calculate next date
                    const newNextDue = calculateNextDue(currentNextDue, rule.frequency, rule.interval);
                    
                    // Update current loop variable
                    currentNextDue = newNextDue;
                    ruleUpdated = true;
                    processedCount++;
                    safetyLimit++;
                } catch (e) {
                    console.error(`Failed to process rule ${rule.id}`, e);
                    break; // Stop processing this rule on error
                }
            }
            
            // If we generated transactions, update the rule's nextDue on server ONCE
            if (ruleUpdated) {
                 await updateRule(rule.id, {
                    lastGenerated: new Date().toISOString(), // Or the actual last transaction date
                    nextDue: currentNextDue.toISOString()
                });
            }
        }

        if (processedCount > 0) {
            console.log(`[RecurringService] Generated ${processedCount} recurring transactions.`);
        }
    };

    return { processRules };
};

const calculateNextDue = (current: Date, freq: string, interval: number): Date => {
    switch (freq) {
        case 'daily': return addDays(current, interval);
        case 'weekly': return addWeeks(current, interval);
        case 'monthly': return addMonths(current, interval);
        case 'yearly': return addYears(current, interval);
        default: return addDays(current, interval);
    }
};
